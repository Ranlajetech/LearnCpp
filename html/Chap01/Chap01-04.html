<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>
        1.4 -- 变量的赋值与初始化
    </title>

    <link rel="stylesheet" href="../../css/main.css"/>
    <link rel="stylesheet" href="../../css/highlightjs.css">
    <link rel="stylesheet" href="../../css/linenumbercool.css"/>
    <script src="../../script/highlight.js"></script>
    <script src="../../script/highlight-cpp.js"></script>
    <script src="../../script/highlightjs-line-numbers.js"></script>
    <script>hljs.highlightAll();</script>
    <script>hljs.initLineNumbersOnLoad({singleLine: true});</script>
</head>

<body>
<h1>
    1.4 -- 变量的赋值与初始化
</h1>
    <p>
        在上一课（<a href="Chap01-03.html" target="_blank">1.3 -- 对象与变量简介</a>）中，我们学习了怎样定义可以存储值的变量。这一课里，我们会继续探索实际上怎么把值存进变量里并使用这些值。
    </p>
    <p>
        作为提示，这有一条代码片段，首先分配了一个名为 <code class="inline">x</code> 的整数变量，然后又分配了两个名为 <code class="inline">y</code> 和 <code class="inline">z</code> 的整数变量。
    </p>
    <pre><code class="language-cpp">int x;    // 定义整数变量 x
int y, z; // 定义两个整数变量 y 和 z</code></pre>
<h2>
    变量的赋值
</h2>
    <p>
        变量定义之后，可以（在另外的语句里）通过 <code class="inline">=</code> 运算符 给它一个值。这个过程称为 <strong>赋值</strong>（<strong>assignment</strong>），<code class="inline">=</code> 运算符 称为 <strong>赋值运算符</strong>（<strong>assignment operator</strong>）。
    </p>
    <pre><code class="language-cpp">int width; // 定义整数变量 width
width = 5; // 给变量 width 赋值为 5

// 变量 width 现在的值为 5</code></pre>
    <p>
        默认情况下，赋值会把 <code class="inline">=</code> 运算符 右侧的值复制到左侧的变量上。这称为 <strong>复制赋值</strong>（<strong>copy assignment</strong>）
    </p>
    <p>
        这个示例中两次使用赋值：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
	int width;
	width = 5; // 给变量 width 复制赋值为 5

	std::cout &lt;&lt; width; // 显示 5

	width = 7; // 把存储在变量 width 里的值改为 7

	std::cout &lt;&lt; width; // 显示 7

	return 0;
}</code></pre>
    <p>
        结果显示：
    </p>
    <pre><code class="language-plaintext nohljsln lighter">57</code></pre>
    <p>
        当给变量 <code class="inline">width</code> 赋值为 <code class="inline">7</code> 时，之前的值 <code class="inline">5</code> 就被覆盖掉了。一般变量在任意时刻都只能存储一个值。
    </p>
    <div class="learncpp-blocktext-red">
        <p class="learncpp-block-title">
            警告
        </p>
        <p>
            新程序员最常犯的错误之一就是把赋值运算符（<code class="inline">=</code>）和相等运算符（<code class="inline">==</code>）弄混。赋值（<code class="inline">=</code>） 是把值赋给变量。相等（<code class="inline">==</code>）是比较两个操作数的值是否相等。
        </p>
    </div>
<h2>
    初始化
</h2>
    <p>
        赋值的一个缺点是需要两条语句：一条定义变量，一条给它赋值。
    </p>
    <p>
        这两步可以结合到一起。定义变量时，可以同时给它提供一个初始值。这叫做 <strong>初始化</strong>（<strong>initialization</strong>）。这个用于初始化变量的值称为 <strong>初始化器</strong>（<strong>initializer</strong>）。
    </p>
    <p>
        C++ 的初始化出人意料地很复杂，这里只展示一个简化的图景。
    </p>
    <p>
        C++ 初始化变量有 6 种基本方式：
    </p>
    <pre><code class="language-cpp">int a;         // 无初始化 (默认初始化)
int b = 5;     // 初始化器在赋值运算符后 (复制初始化)
int c( 6 );    // 初始化器在圆括号里 (直接初始化)

// 列表初始化方法 (C++11) (推荐)
int d { 7 };   // 初始化器在花括号里 (直接列表初始化)
int e = { 8 }; // 初始化器在赋值运算符后的花括号里 (复制列表初始化)
int f {};      // 初始化器是空花括号 (值初始化)</code></pre>
    <p>
        你可能会在别处看到类似的格式但使用空格的方式不同（比如 <code class="inline">int d{7};</code>）。有没有额外的空格只是个人风格偏好。
    </p>
<h2>
    默认初始化
</h2>
    <p>
        不提供初始化值（比如上面的变量 <code class="inline">a</code>），就是 <strong>默认初始化</strong>（<strong>default initialization</strong>）。绝大多数情况下，默认初始化会使变量具有一个不确定的值。
    </p>
    <p>
        在 <a href="Chap01-06.html" target="_blank">1.6 -- 未初始化的变量与未定义行为</a> 一课中会深入讨论这一点。
    </p>
<h2>
    复制初始化
</h2>
    <p>
        初始化器在赋值运算符后时，称作 <strong>复制初始化</strong>（<strong>copy initialization</strong>）。这种初始化方式继承自 C。
    </p>
    <pre><code class="language-cpp">int width = 5; // 把变量 width 复制初始化为 5</code></pre>
    <p>
        和复制赋值很类似，这会把赋值运算符右侧的值复制到左侧刚创建的变量上。在上面的代码片段中，变量 <code class="inline">width</code> 复制初始化为 <code class="inline">5</code>。
    </p>
    <p>
        复制初始化在现代 C++ 里已不再流行，因为它在复杂的类型的初始化上没有其他初始化方式高效。但 C++17 修复了大部分问题，复制初始化重新获得了一些拥护者。你会在一些老代码（尤其是从 C 移植过来的代码）中看到复制初始化，或者在那些单纯认为这么写更自然更易读的程序员写出的代码里看到。
    </p>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            延申阅读
        </p>
        <p>
            当值被隐式复制或转换时会使用复制初始化，例如给函数参数传值，函数返回一个值，或按值捕获异常时。
        </p>
    </div>
<h2>
    直接初始化
</h2>
    <p>
        初始化器在圆括号里时，叫做 <strong>直接初始化</strong>（<strong>direct initialization</strong>）。
    </p>
    <pre><code class="language-cpp">int width( 5 ); // 把变量 width 直接初始化为 5</code></pre>
    <p>
        最开始引入直接初始化是为了让复杂的对象（指 class 类的对象，在以后的章节里会讲）的初始化更高效。和复制初始化一样，直接初始化在现代 C++ 里也不再流行，主要是因为被列表初始化取代了。但我们现在知道列表初始化也有一些缺陷，所以在某些情况下直接初始化又有了用处。
    </p>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            延申阅读
        </p>
        <p>
            值被显式地转换成其他类型时就会使用直接初始化。
        </p>
        <p>
            直接初始化被弃用的直接原因之一是很难区分开变量和函数。例如：
        </p>
        <pre><code class="language-cpp">int x();  // 函数 x 的前向声明(forward declaration)
int x(0); // 定义变量 x 并初始化为 0</code></pre>
    </div>
<h2>
    列表初始化
</h2>
    <p>
        C++ 初始化对象的现代方法是使用花括号的形式。这叫 <strong>列表初始化</strong>（<strong>list initialization</strong>）或 <strong>统一初始化</strong>（<strong>uniform initialization</strong>）或 <strong>花括号初始化</strong>（<strong>brace initialization</strong>）。
    </p>
    <p>
       列表初始化有三种形式： 
    </p>
    <pre><code class="language-cpp">int width { 5 };    // 把变量 width 列表初始化为 5
int height = { 6 }; // 把变量 height 复制列表初始化为 6
int depth {};       // 值初始化 (见下一节)</code></pre>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            延申阅读
        </p>
        <p>
            在介绍列表初始化之前，某些情况需要使用复制初始化，某些需要直接初始化。列表初始化提供了一个绝大多数情况下都有效的更有一致性的初始化语法（这就是为什么它有时被称为统一初始化）。
        </p>
        <p>
            另外，列表初始化提供了一种使用值列表初始化对象的方法（这就是为什么它被称为列表初始化）。在 <a href="../Chap16/Chap16-02.html" target="_blank">16.2 -- std::vector 与列表构造函数简介</a> 一章可以看到示例。
        </p>
    </div>
    <p>
        列表初始化还有一个好处：它不允许“窄化转换”。如果尝试在列表初始化时使用变量的类型不能安全存储的值，编译器就会抛出错误。例如：
    </p>
    <pre><code class="language-cpp">int width { 4.5 }; // 错误: 带有小数部分的值放不到整数里。</code></pre>
    <p>
        在上面的代码片段中，尝试把带有小数部分的数值 <code class="inline">4.5</code> 赋给整数变量，而后者只能存储不带小数部分的值。
    </p>
    <p>
        复制初始化和直接初始化会直接舍掉小数部分，把变量 <code class="inline">width</code> 初始化为值 <code class="inline">4</code>（编译器可能会抛出警告，因为希望丢失数据的情形很罕见）。然而，使用列表初始化会直接抛出错误，强迫你在继续之前修复这个问题。
    </p>
    <p>
        不会造成数据丢失的转换是被允许的。
    </p>
    <p>
        总的来说，一般更推荐列表初始化，因为它在绝大多数情况下都适用，不允许窄化转换，支持用值列表作初始化（以后的课程中会提到）。学习过程中，推荐一直使用列表初始化（或值初始化）。
    </p>
    <div class="learncpp-blocktext-green">
        <p class="learncpp-block-title">
            最佳实践
        </p>
        <p>
            用列表初始化（或值初始化）初始化变量。
        </p>
    </div>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            作者的话
        </p>
        <p>
            Bjarne Stroustrup（C++ 的创造者）和 Herb Sutter（C++ 专家）推荐 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list" title="Github" target="_blank">使用列表初始化</a> 来初始化变量。
        </p>
        <p>
            在现代 C++ 中，也存在一些列表初始化不能按预期工作的情形。在 <a href="../Chap16/Chap16-02.html" target="_blank">16.2 -- std::vector 与列表构造函数简介</a> 一章会讲到这样的情况。
        </p>
        <p>
            由于这些缺陷，一些经验丰富的开发人员现在主张根据具体情况混合使用复制、直接和列表初始化。当你对语言足够熟悉，理解了每种初始化方式之间的细微差别以及这些建议背后的理由，你就可以自行评估这些论点是否具有说服力。
        </p>
    </div>
<h2>
    值初始化和零初始化
</h2>
    <p>
        用空花括号初始化变量时，就是 <strong>值初始化</strong>（<strong>value initialization</strong>）。绝大多数情况下，值初始化会把变量置零（或空，取决于对应的类型来说哪个更合适）。当发生这种置零行为时，称为 <strong>零初始化</strong>（<strong>zero initialization</strong>）。
    </p>
    <pre><code class="language-cpp">int width {}; // 值初始化 / 零初始化为 0</code></pre>
    <div class="learncpp-blocktext-violet">
        <p class="learncpp-block-head-content">
            Q：如何区分使用 <code class="inline">{0}</code> 和 <code class="inline">{}</code>？
        </p>
        <p>
            如果实际使用了这个值，那就使用显式的值来初始化。
        </p>
        <pre><code class="language-cpp">int x { 0 };    // 显式初始化为值 0
std::cout &lt;&lt; x; // 正在使用零值</code></pre>
        <p>
            如果是临时的、马上要被取代的值，就使用值初始化。
        </p>
        <pre><code class="language-cpp">int x {};      // 值初始化
std::cin &gt;&gt; x; // 马上就取代了之前的值</code></pre>
    </div>
<h2>
    把变量初始化
</h2>
    <p>
        在创建变量时立即初始化。以后可能会遇到由于某些特别原因想要忽略这条建议的情况（比如使用了大量变量同时对性能要求很高的代码），没关系，只要是有意为之就可以。
    </p>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            延申阅读
        </p>
        <p>
            在这个问题上，Bjarne Stroustrup（C++ 的创造者）和 Herb Sutter（C++ 专家）在 <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object" title="Github" target="_blank">这里</a> 给出了他们的建议。
        </p>
    </div>
    <p>
        在 <a href="Chap01-06" target="_blank">1.6 -- 未初始化的变量与未定义行为</a> 一节中，我们会探讨使用没有良定义值的变量会发生什么。
    </p>
    <div class="learncpp-blocktext-green">
        <p class="learncpp-block-title">
            最佳实践
        </p>
        <p>
            在创建变量时立即初始化。
        </p>
    </div>
<h2>
    初始化多个变量
</h2>
    <p>
        在上一节，注意到可以在单条语句中定义多个用逗号分隔的同种类型的变量：
    </p>
    <pre><code class="language-cpp">int a, b;</code></pre>
    <p>
        注意最佳实践推荐避免使用这种写在一起的语法。然而，因为有可能会遇到使用这种风格的代码，这里还是多讨论一些，同时多展示几个应当回避这种写法的原因。
    </p>
    <p>
        你可以初始化定义在同一行的多个变量：
    </p>
    <pre><code class="language-cpp">int a = 5, b = 6;          // 复制初始化
int c( 7 ), d( 8 );        // 直接初始化
int e { 9 }, f { 10 };     // 直接列表初始化
int g = { 9 }, h = { 10 }; // 复制列表初始化
int i {}, j {};            // 值初始化</code></pre>
    <p>
        不幸的是，这里存在几个陷阱，程序员错误地想要用一条语句初始化多个变量：
    </p>
    <pre><code class="language-cpp">int a, b = 5; // 不正确: a 没有初始化

int a = 5, b = 5; // 正确</code></pre>
    <p>
        在上面的语句中，变量 <code class="inline">a</code> 没有初始化，编译器不一定会报错。如果没有，那么很可能会导致你的程序间歇性崩溃或出现偶发性问题。我们不久之后就会讨论使用未初始化的变量会发生什么。
    </p>
    <p>
        记住这是错误的最好方式是考虑直接初始化和列表初始化的情形：
    </p>
    <pre><code class="language-cpp">int a, b( 5 );
int c, d{ 5 };</code></pre>
    <p>
        因为圆括号、花括号都直接放在变量名右侧，所以更容易看出来值 <code class="inline">5</code> 只用来初始化变量 <code class="inline">b</code> 和 <code class="inline">d</code>，而不是 <code class="inline">a</code> 或 <code class="inline">c</code>。
    </p>
<h2>
    初始化后未使用的变量造成的警告
</h2>
    <p>
        现代编译器大多会在初始化后未使用的变量上抛出警告（因为这一般不是想要的行为）。如果开启了“把警告当作错误”，这些警告会被升级成错误造成编译失败。
    </p>
    <p>
        考虑下面这个看起来无害的程序：
    </p>
    <pre><code class="language-cpp">int main()
{
    int x { 5 }; // 变量定义了

    // 但是没被使用

    return 0;
}</code></pre>
    <p>
        用 g++ 编译器编译会产生如下错误：
    </p>
    <pre><code class="language-plaintext nohljsln lighter">prog.cc: In function 'int main()':
prog.cc:3:9: error: unused variable 'x' [-Werror=unused-variable]</code></pre>
    <p>
        程序编译失败。
    </p>
    <p>
        有几个简单方法修复。
    </p>
    <ol>
        <li>如果真的没有使用过，那就移除它的定义（或者注释掉）。毕竟没使用过就不会造成影响。</li>
        <li>也可以简单地在某处使用它：<br/>
            <pre style="line-height: initial;"><code class="language-cpp">#include <iostream>

int main()
{
    int x { 5 };

    std::cout &lt;&lt; x; // 在某处使用了这个变量

    return 0;
}</code></pre>
        </li>
    </ol>
    <p>
        但这就要花费功夫写一段代码利用它，而且可能会改变程序的行为。
    </p>
<h2>
    <code class="inline">[[maybe_unused]]</code> 属性 <span class="learncpp-language-standard">C++17</span>
</h2>
    <p>
        某些情况下，上面的两种方法都不合适。考虑在数学或物理计算中常用的常数：
    </p>
    <pre><code class="language-cpp">int main()
{
    double pi { 3.14159 };
    double gravity { 9.8 };
    double phi { 1.61803 };

    // 假设上面一部分用到了, 一部分没用到

    return 0;
}</code></pre>
    <p>
        如果经常使用，那么可能要把它存到某处，然后一次性复制粘贴或导入进来。
    </p>
    <p>
        然而，如果有程序没用全所有的这些变量，编译器就会报错说某个变量未使用。尽管可以逐个查找并注释掉没用过的变量，但这费时费力。要是以后又需要用了，还得返回去加回来。
    </p>
    <p>
        为了解决这种情况，C++17 引入了 <code class="inline">[[maybe_unused]]</code> 属性，可以用来告诉编译器允许这个变量保持未使用状态。这样编译器就不会在这些变量未使用时抛出警告了。
    </p>
    <p>
        下面的程序应当不会产生警告或错误：
    </p>
    <pre><code class="language-cpp">int main()
{
    [[maybe_unused]] double pi { 3.14159 };
    [[maybe_unused]] double gravity { 9.8 };
    [[maybe_unused]] double phi { 1.61803 };

    // 上面的变量不会产生未使用变量的警告

    return 0;
}</code></pre>
    <p>
        另外，编译器可以把这些变量优化掉，所以不会产生性能影响。
    </p>
    <div class="learncpp-blocktext-grey">
        <p class="learncpp-block-title">
            作者的话
        </p>
        <p>
            在以后的教程里，经常会为了讲述某个概念而定义不会再使用的变量。使用 <code class="inline">[[maybe_unused]]</code> 就可以避免产生编译警告或错误。
        </p>
    </div>
<h2>
    <a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/#:~:text=Quiz%20time" target="_blank">随堂小测</a>
</h2>
<hr/>
<nav>
    <a href="Chap01-05.html">[ 下一课：1.5 -- <em>iostream</em> 简介：<code>cout</code>，<code>cin</code>，<code>endl</code> ]</a><br/>
    <a href="../../index.html" target="_blank">[ 目录 ]</a><br/>
    <a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/" target="_blank">[ 原文地址 ]</a><br/>
    <a href="Chap01-03.html">[ 上一课：1.3 -- 对象与变量简介 ]</a>
</nav>
</body>
</html>